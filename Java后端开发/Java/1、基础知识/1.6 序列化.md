# 一、序列化和反序列化定义

序列化是将对象的状态信息转换为可存储或传输形式的过程,一般是以字节码或XML格式传输

而字节码或XML编码格式可以还原为完全相等的对象，这个相反的过程称为反序列化

# 二、如何实现序列化

相关接口和类：

- java.io.Serializable
- java.io.Externalizable
- ObjectOutput
- ObjectInput
- ObjectOutputStream
- ObjectInputStream

## 2.1 Serializable接口

类通过实现 `java.io.Serializable` 接口以启用其序列化功能

如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该集成`java.io.Serializable`接口

> 序列化接口没有方法或字段，仅用于标识可序列化的语义

## 2.2 Externalizable接口

Externalizable继承了Serializable

该接口中定义了两个抽象方法：

- `writeExternal()`
- `readExternal()`

当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写`writeExternal()`与`readExternal()`方法

> 在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器

## 2.3 serialVersionUID

反序列化时，JVM会把传来的字节流中的`serialVersionUID`与本地相应实体类的`serialVersionUID`进⾏⽐较， 如果相同就认为是⼀致的， 可以进⾏反序列化， 否则就会出现序列化版本不⼀致的异常， 即是`InvalidCastException`

当实现`java.io.Serializable`接口的类没有显式地定义⼀个`serialVersionUID`变量时候， Java序列化机制会根据编译的Class⾃动⽣成⼀个`serialVersionUID`作序列化版本⽐较⽤， 这种情况下， 如果Class⽂件没有发⽣变化， 就算再编译多 次， serialVersionUID也不会变化的

# 三、序列化的底层原理

